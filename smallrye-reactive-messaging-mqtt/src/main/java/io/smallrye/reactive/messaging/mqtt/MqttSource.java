package io.smallrye.reactive.messaging.mqtt;

import java.util.NoSuchElementException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.eclipse.microprofile.config.Config;
import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;
import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.reactivex.BackpressureStrategy;
import io.reactivex.Observable;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.reactivex.core.Vertx;
import io.vertx.reactivex.mqtt.MqttClient;

public class MqttSource {

    private final Logger LOGGER = LoggerFactory.getLogger(MqttSource.class);
    private final PublisherBuilder<MqttMessage<?>> source;
    private AtomicBoolean subscribed = new AtomicBoolean();

    public MqttSource(Vertx vertx, Config config) {
        MqttClientOptions options = new MqttClientOptions();
        options.setClientId(config.getOptionalValue("client-id", String.class).orElse(null));
        options.setAutoGeneratedClientId(config.getOptionalValue("auto-generated-client-id", Boolean.class)
                .orElse(false));
        options.setAutoKeepAlive(config.getOptionalValue("auto-keep-alive", Boolean.class)
                .orElse(true));
        options.setSsl(config.getOptionalValue("ssl", Boolean.class).orElse(false));
        options.setWillQoS(config.getOptionalValue("will-qos", Integer.class).orElse(0));
        options.setKeepAliveTimeSeconds(config.getOptionalValue("keep-alive-seconds", Integer.class)
                .orElse(30));
        options.setMaxInflightQueue(config.getOptionalValue("max-inflight-queue", Integer.class)
                .orElse(10));
        options.setCleanSession(config.getOptionalValue("auto-clean-session", Boolean.class)
                .orElse(true));
        options.setWillFlag(config.getOptionalValue("will-flag", Boolean.class).orElse(false));
        options.setWillRetain(config.getOptionalValue("will-retain", Boolean.class).orElse(false));
        options.setMaxMessageSize(config.getOptionalValue("max-message-size", Integer.class).orElse(-1));
        options.setReconnectAttempts(config.getOptionalValue("reconnect-attempts", Integer.class).orElse(5));
        options.setReconnectInterval(TimeUnit.SECONDS.toMillis(
                config.getOptionalValue("reconnect-interval-seconds", Integer.class).orElse(1)));
        options.setUsername(config.getOptionalValue("username", String.class).orElse(null));
        options.setPassword(config.getOptionalValue("password", String.class).orElse(null));
        options.setConnectTimeout((int) TimeUnit.SECONDS.toMillis(
                config.getOptionalValue("connect-timeout-seconds", Integer.class).orElse(60)));
        options.setTrustAll(config.getOptionalValue("trust-all", Boolean.class).orElse(false));

        String host = config.getOptionalValue("host", String.class).orElseThrow(() -> new NoSuchElementException(
                "Invalid configuration - expected key `host` to be present in " + config.getPropertyNames()));
        int def = options.isSsl() ? 8883 : 1883;
        int port = config.getOptionalValue("port", Integer.class).orElse(def);
        String server = config.getOptionalValue("server-name", String.class).orElse(null);
        String topic = getTopicOrFail(config);
        MqttClient client = MqttClient.create(vertx, options);
        int qos = config.getOptionalValue("qos", Integer.class).orElse(0);
        boolean broadcast = config.getOptionalValue("broadcast", Boolean.class).orElse(false);

        this.source = ReactiveStreams.fromPublisher(
                client.rxConnect(port, host, server)
                        .flatMapObservable(a -> Observable.<MqttMessage<?>> create(emitter -> {
                            client.publishHandler(message -> {
                                emitter.onNext(new ReceivingMqttMessage(message));
                            });
                            client.subscribe(topic, qos, done -> {
                                if (done.failed()) {
                                    // Report on the flow
                                    emitter.onError(done.cause());
                                }
                                subscribed.set(done.succeeded());
                            });
                        }))
                        .toFlowable(BackpressureStrategy.BUFFER)
                        .compose(f -> {
                            if (broadcast) {
                                return f.publish().autoConnect();
                            } else {
                                return f;
                            }
                        })
                        .doOnCancel(() -> {
                            subscribed.set(false);
                            client.disconnect();
                        })
                        .doOnError(t -> LOGGER.error("Unable to establish a connection with the MQTT broker", t)));
    }

    PublisherBuilder<MqttMessage<?>> getSource() {
        return source;
    }

    boolean isSubscribed() {
        return subscribed.get();
    }

    private String getTopicOrFail(Config config) {
        return config.getOptionalValue("topic", String.class)
                .orElseGet(
                        () -> config.getOptionalValue("channel-name", String.class)
                                .orElseThrow(() -> new IllegalArgumentException("Topic attribute must be set")));
    }
}
